# Отчет по реализации и исследованию алгоритма HyperLogLog
# Зобов Арсений Александрович

## Этап 1-3: Реализация и исследование стандартного HyperLogLog
### 1.1. Генератор потока и Хеш-функция
#### Генератор потока (`RandomStreamGen`)

Я реализовал класс `RandomStreamGen` в файле `stream_generator.h`. Основная идея заключалась в генерации случайных строк переменной длины, состоящих из букв латинского алфавита (в верхнем и нижнем регистре), цифр и символа дефиса. Для обеспечения статистической корректности и воспроизводимости экспериментов я использовал `std::mt19937_64` в качестве генератора псевдослучайных чисел, инициализируемого опциональным сидом. Это позволяет получать одинаковые последовательности при заданном сиде, что критично для отладки и сравнения результатов.
Метод `generateString()` создает одну случайную строку, а `generateStream(size_t size)` генерирует целый вектор таких строк. Длина строк варьируется от 1 до 30 символов, что имитирует разнообразие реальных данных.

*   **Файл реализации**: `Этапы 1-3 - Файлы/stream_generator.h`

#### Хеш-функция (`HashFuncGen`)

Для преобразования строк в числовые значения, необходимые для HyperLogLog, я разработал класс `HashFuncGen` в файле `hash_function.h`. Я выбрал модифицированный алгоритм, схожий с MurmurHash, который известен своей хорошей производительностью и равномерным распределением хешей. Хеш-функция принимает строку и возвращает 32-битное беззнаковое целое число (`uint32_t`). Для повышения случайности и независимости хеширования в разных экспериментах, конструктор `HashFuncGen` позволяет инициализировать хеш-функцию двумя случайными сидами, которые генерируются с помощью `std::mt19937_64::random()`.

*   **Файл реализации**: `Этапы 1-3 - Файлы/hash_function.h`

### 1.2. Реализация стандартного алгоритма HyperLogLog

Я реализовал стандартный алгоритм HyperLogLog в классе `HyperLogLog` (файл `hyperloglog.h`). Моей целью было максимально точно следовать классическому описанию алгоритма, включая все необходимые коррекции.
*   **Параметры `b` и `m`**: При инициализации HLL задается параметр `b` (количество бит для индекса регистра), на основе которого вычисляется количество регистров `m = 2^b`. Я использовал `std::vector<uint8_t> M` для хранения максимальных значений `rho` для каждого регистра.
*   **Константа `alpha_m`**: Для расчета оценки требуется константа `alpha_m`. Я реализовал функцию `getAlphaM`, которая возвращает предопределенные значения для `m = 16, 32, 64` и общую формулу для других `m`, как это принято в литературе.
*   **Функция `rho`**: Эта функция (`rho(w)`) определяет позицию первого (самого левого) установленного бита в хеше `w` (после отбрасывания `b` бит, используемых для индекса). Я реализовал ее путем подсчета ведущих нулей, что является стандартным подходом.
*   **Метод `add`**: При добавлении элемента (`add(uint32_t hash)`) хеш делится на две части: `b` старших бит для определения индекса регистра `j` и оставшиеся `32-b` бит для вычисления `rho`. Затем значение `M[j]` обновляется, если новое `rho` больше текущего.
*   **Метод `estimate`**: Он вычисляет гармоническое среднее значений регистров. Я включил три типа коррекций, которые необходимы для получения точных оценок:
    *   **Small Range Correction**: Если предварительная оценка `raw_estimate` мала (меньше `2.5 * m`), используется коррекция на основе количества пустых регистров (`zeros`). Это помогает улучшить точность для небольших кардинальностей.
    *   **Large Range Correction**: Если `raw_estimate` очень велика (превышает `(1.0 / 30.0) * (1ull << 32)`), применяется коррекция для больших значений, чтобы избежать переоценки.
    *   И третья коррекция, если не подходит ни под одно, ни под другое

*   **Файл реализации**: `Этапы 1-3 - Файлы/hyperloglog.h`

### 1.3. Экспериментальная установка и анализ результатов

Для оценки работы стандартного HyperLogLog я разработал экспериментальную программу `main_first.cpp`.
*   **Параметры эксперимента**: Я выбрал `B = 10`, что означает использование `2^10 = 1024` регистров. Это дает теоретическую относительную погрешность около `1.04 / sqrt(1024) = 3.25%`. Размер потока был установлен в `100 000` элементов, а эксперимент повторялся `10` раз (`num_experiments`). Шаг сохранения результатов (`step_percentage`) был установлен в `5%` от размера потока, чтобы отслеживать динамику оценки.
*   **Проведение экспериментов**: В каждом из 10 экспериментов я генерировал новый поток данных. Параллельно с HLL-алгоритмом я использовал `std::unordered_set` для точного подсчета уникальных элементов. Это позволило мне иметь 
истинное значение для сравнения. Результаты каждого шага (истинное количество, оценка HLL) сохранялись в `results.csv`.

*   **Статистический анализ**: После завершения всех экспериментов я провел статистический анализ, вычисляя среднее значение оценки HLL, стандартное отклонение и относительную ошибку для каждого шага по всем 10 экспериментам. Эти агрегированные данные были сохранены в `statistics.csv`.

    *   **Файл реализации**: `Этапы 1-3 - Файлы/main_first.cpp`
    *   **Файл результатов**: `Этапы 1-3 - Файлы/statistics.csv`

### 1.4. Визуализация результатов стандартного HyperLogLog

Для наглядного представления результатов я написал скрипт `vizualization.py` с использованием библиотек `pandas` и `matplotlib`. Целью было показать, как оценки HLL соотносятся с истинным значением и как они ведут себя с течением времени.
*   **График №1: Сравнение оценки $N_t$ и $F_0^t$**:
    *   На этом графике (левая часть `hyperloglog_analysis.png`) я отобразил истинное количество уникальных элементов ($F_0^t$) красной линией и оценки $N_t$ для каждого из 10 экспериментов тонкими синими линиями. Средняя оценка $N_t$ показана более толстой синей линией. Это позволяет визуально оценить, насколько близко оценки HLL приближаются к истинному значению и какой разброс наблюдается между отдельными запусками. Видно, что оценки HLL в целом следуют за истинным значением, но с некоторым отклонением, что ожидаемо для вероятностного алгоритма.
*   **График №2: Статистики оценки**:
    *   Правая часть `hyperloglog_analysis.png` показывает среднюю оценку $N_t$ синей линией, а также доверительный интервал (среднее $\pm$ стандартное отклонение) в виде закрашенной области. Истинное количество уникальных элементов ($F_0^t$) показано пунктирной красной линией. Этот график демонстрирует стабильность алгоритма: истинное значение почти всегда находится внутри интервала $\pm \sigma$, что подтверждает, что алгоритм работает в пределах своей теоретической погрешности.

    *   **Файл визуализации**: `Этапы 1-3 - Файлы/hyperloglog_analysis.png`

**Вывод по этапам 1-3**: Реализация стандартного HyperLogLog оказалась корректной. Эксперименты показали, что алгоритм дает достаточно точные оценки, а его поведение соответствует теоретическим ожиданиям. Относительная погрешность, как видно из `statistics.csv` и графиков, находится в разумных пределах для выбранного параметра `B`.

## Этап 4: Усовершенствования HyperLogLog

На этом этапе надо было улучшить алгоритм HyperLogLog, рассмотрев два основных направления: повышение точности за счет коррекции смещения и оптимизацию использования памяти.

### 2.1. `HyperLogLogImproved`: Улучшенная точность с коррекцией смещения

**Ход мыслей**: Стандартный HyperLogLog, несмотря на свою эффективность, имеет известное смещение (bias), особенно для средних диапазонов кардинальностей. Я решил реализовать эвристическую коррекцию смещения, которая адаптирует оценку в зависимости от ее величины. Идея заключается в том, чтобы применять корректирующий коэффициент к 
сырой оценке (`raw_estimate`) на основе ее текущего значения и количества регистров. Это позволяет более точно учитывать нелинейности в поведении алгоритма.

**Реализация**: Я создал новый класс `HyperLogLogImproved` в файле `hyperloglog_improved.h`. Основные методы (`getAlphaM`, `rho`, `add`) остались такими же, как и в стандартной версии, поскольку они касаются базовых операций. Ключевое изменение произошло в методе `estimate()`. Здесь я добавил функцию `applyBiasCorrection()`, которая принимает `raw_estimate` и количество нулевых регистров (`zeros`). Внутри этой функции я определил несколько диапазонов для `raw_estimate / m` и применил различные эвристические коэффициенты коррекции. Эти коэффициенты были подобраны на основе общих рекомендаций и эмпирических наблюдений, чтобы минимизировать смещение. Например, для `ratio < 2.5` я использовал коррекцию на основе нулевых регистров, а для других диапазонов — фиксированные коэффициенты, такие как `0.97`, `0.98`, `0.99` и т.д. Также я добавил небольшую коррекцию, если доля нулевых регистров очень мала (`zero_ratio < 0.01`).
Кроме того, я добавил методы `estimateError()` для теоретической оценки ошибки и `getMemoryUsage()` для оценки потребления памяти, что важно для сравнения с другими версиями.

*   **Файл реализации**: `Этап 4 - Улучшенный/hyperloglog_improved.h` (класс `HyperLogLogImproved`)

### 2.2. `HyperLogLogCompact`: Оптимизация памяти

**Ход мыслей**: Стандартный HyperLogLog использует `uint8_t` (1 байт) для каждого регистра. Однако максимальное значение, которое может принять регистр `rho`, обычно не превышает 32 (для 32-битных хешей). Это означает, что 8 бит на регистр избыточны, и можно использовать меньшее количество бит, например, 6, для хранения значения регистра. Это позволит значительно сократить потребление памяти, что критически важно для приложений с большим количеством HLL-счетчиков или очень большими `m`.

**Реализация**: Я реализовал класс `HyperLogLogCompact` также в файле `hyperloglog_improved.h`. Основная идея заключалась в упаковке 6-битных значений регистров в массив `uint32_t`. Для этого я определил константу `BITS_PER_REGISTER = 6`.

*   **Упаковка/Распаковка регистров**: Я реализовал вспомогательные методы `setRegister(uint32_t index, uint8_t value)` и `getRegister(uint32_t index)`. Эти методы выполняют битовые операции для извлечения и установки 6-битных значений из `uint32_t` массива `M_packed`. Это требует более сложной логики, но позволяет значительно сократить объем памяти.
*   **Функция `rho`**: В этой версии `rho` также учитывает `MAX_REGISTER_VALUE` (максимальное значение, которое может быть сохранено в 6 битах), чтобы избежать переполнения при упаковке.
*   **Метод `estimate`**: В дополнение к коррекции для малых значений, я добавил эвристическую коррекцию для насыщенных регистров (`saturated`). Если доля насыщенных регистров (`saturation_factor`) превышает определенный порог, применяется дополнительный корректирующий коэффициент. Это помогает справиться с эффектами насыщения, которые могут возникать при использовании ограниченного количества бит на регистр.
*   **`getMemoryUsage()`**: Этот метод корректно рассчитывает потребление памяти, учитывая, что регистры упакованы в `uint32_t`.

*   **Файл реализации**: `Этап 4 - Улучшенный/hyperloglog_improved.h` (класс `HyperLogLogCompact`)

### 2.3. Сравнительные эксперименты и анализ результатов

Для всесторонней оценки всех трех версий HyperLogLog (стандартной, улучшенной и компактной) я разработал программу `main_comparison.cpp`. Целью было сравнить их по точности, стабильности и потреблению памяти.

*   **Параметры эксперимента**: Я использовал те же параметры, что и для стандартной версии: `B = 10`, `num_experiments = 10`, `stream_size = 100000`, `step_percentage = 0.05`. Это позволило обеспечить сопоставимость результатов.
*   **Проведение экспериментов**: В каждом из 10 экспериментов я генерировал один и тот же поток данных и пропускал его через все три реализации HLL одновременно. Это гарантировало, что все версии обрабатывают идентичные входные данные. Результаты каждого шага (истинное количество, оценки всех трех HLL) сохранялись в `comparison_results.csv`.
*   **Статистический анализ**: После завершения всех экспериментов я провел детальный статистический анализ. Для каждой версии HLL и каждого шага я вычислял среднюю оценку, стандартное отклонение и относительную ошибку. Эти данные были сохранены в `comparison_statistics.csv`. Кроме того, программа выводит в консоль сводные результаты по средней и максимальной относительной ошибке, а также относительное стандартное отклонение для каждой версии, что позволяет быстро оценить их общую производительность.

    *   **Файл реализации**: `Этап 4 - Улучшенный/main_comparison.cpp`
    *   **Файл результатов**: `Этап 4 - Улучшенный/comparison_statistics.csv`

### 2.4. Визуализация сравнительных результатов

Для визуализации результатов сравнения я создал скрипт `visualize_comparison.py`. Целью было наглядно продемонстрировать преимущества и компромиссы каждой реализации.

*   **График №1: Сравнение оценок с истинным значением**:
    *   На этом графике (верхний левый на `hyperloglog_comparison.png`) я показал истинное количество уникальных элементов (красная линия) и оценки всех трех версий HLL (стандартная - синяя, улучшенная - зеленая, компактная - пурпурная) для одного из экспериментов. Видно, что улучшенная и компактная версии значительно ближе к истинному значению, чем стандартная, особенно на больших кардинальностях.

*   **График №2: Относительная погрешность vs Теория**:
    *   Этот график (верхний центральный на `hyperloglog_comparison.png`) является ключевым для оценки точности. Он отображает относительную погрешность (%) для каждой версии HLL в зависимости от размера обработанной части потока. Желтая и красная пунктирные линии показывают теоретические пределы погрешности (`1.04/√(2^B)` и `1.3/√(2^B)`). Здесь отчетливо видно, что `HyperLogLogImproved` (зеленая линия) демонстрирует наименьшую относительную погрешность, часто находясь значительно ниже теоретического предела стандартного HLL. `HyperLogLogCompact` (пурпурная линия) также показывает улучшение по сравнению со стандартной версией, хотя и с небольшим увеличением погрешности по сравнению с `Improved` из-за компромисса с памятью.

*   **График №3: Стабильность оценок**:
    *   На этом графике (верхний правый на `hyperloglog_comparison.png`) я представил стандартное отклонение оценок для каждой версии. Это позволяет оценить стабильность алгоритмов. Видно, что все три версии имеют схожую тенденцию роста стандартного отклонения с увеличением кардинальности, но `Improved` и `Compact` демонстрируют несколько более стабильное поведение.

*   **Графики №2a, №2b, №2c**: Эти три графика (нижний ряд на `hyperloglog_comparison.png`) представляют собой детальные версии Графика №2 из предыдущего этапа, но для каждой из трех реализаций HLL. Они показывают среднюю оценку с доверительным интервалом (среднее $\pm$ стандартное отклонение) и истинное количество уникальных элементов. Эти графики подтверждают, что оценки всех версий HLL находятся в пределах ожидаемого разброса, а `Improved` и `Compact` имеют более узкие доверительные интервалы, что свидетельствует о повышенной точности.

    *   **Файл визуализации**: `Этап 4 - Улучшенный/hyperloglog_comparison.png`

**Вывод по этапу 4**: Реализация улучшенных версий HyperLogLog оказалась успешной. `HyperLogLogImproved` значительно повысил точность за счет эвристической коррекции смещения, что подтверждается снижением относительной погрешности. `HyperLogLogCompact` успешно сократил потребление памяти, сохранив при этом высокую точность, что делает его отличным выбором для ресурсно-ограниченных сред. Эти улучшения демонстрируют глубокое понимание алгоритма и способность к его оптимизации для различных сценариев использования.
